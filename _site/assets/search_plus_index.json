{"/pages/c/editor/xcode/": {
    "title": "Xcode",
    "keywords": "",
    "url": "/pages/c/editor/xcode/",
    "body": "輸入Project的名字 選擇要放置的位置，並點選New Folder 輸入新目錄的名稱 要勾不勾git自行決定，按create 點擊main，再按下執行的按鈕"
  },"/pages/jekyll/install/how_to_install_ruby/": {
    "title": "安裝 Ruby on Mac",
    "keywords": "",
    "url": "/pages/jekyll/install/how_to_install_ruby/",
    "body": "打開終端機，輸入下面指令 $brew install ruby 檢查安裝路徑 $brew list ruby homebrew安裝ruby的路徑列表，注意版號是否為3.0以上，目前是3.3.0。 /usr/local/Cellar/ruby/3.3.0/bin/bundle /usr/local/Cellar/ruby/3.3.0/bin/bundler /usr/local/Cellar/ruby/3.3.0/bin/erb /usr/local/Cellar/ruby/3.3.0/bin/gem /usr/local/Cellar/ruby/3.3.0/bin/irb /usr/local/Cellar/ruby/3.3.0/bin/racc /usr/local/Cellar/ruby/3.3.0/bin/rake /usr/local/Cellar/ruby/3.3.0/bin/rbs /usr/local/Cellar/ruby/3.3.0/bin/rdbg /usr/local/Cellar/ruby/3.3.0/bin/rdoc /usr/local/Cellar/ruby/3.3.0/bin/ri /usr/local/Cellar/ruby/3.3.0/bin/ruby /usr/local/Cellar/ruby/3.3.0/bin/syntax_suggest /usr/local/Cellar/ruby/3.3.0/bin/typeprof /usr/local/Cellar/ruby/3.3.0/include/ruby-3.3.0/ (191 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.3.3.dylib /usr/local/Cellar/ruby/3.3.0/lib/pkgconfig/ruby-3.3.pc /usr/local/Cellar/ruby/3.3.0/lib/ruby/ (4276 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.dylib /usr/local/Cellar/ruby/3.3.0/libexec/gembin/ (2 files) /usr/local/Cellar/ruby/3.3.0/share/emacs/site-lisp/ruby/ruby-style.el /usr/local/Cellar/ruby/3.3.0/share/man/ (4 files) /usr/local/Cellar/ruby/3.3.0/share/ri/ (15158 files) 檢查本機ruby的安裝的位置是否與homebrew一致。 $which ruby 我的mac顯示的位置是∶ /usr/bin/ruby 顯然是不一樣，修改環境變數。 $vi ~/.zshrc 添加homebrew 安裝ruby的路徑，注意!以下的位置是你的brew list ruby的路徑，不能直接拷貝我的。 export PATH=\"/usr/local/Cellar/ruby/3.3.0/bin:$PATH\" 修改完.zshrc檔案，在終端機執行以下指令。 $source ~/.zshrc 檢查ruby的路徑是否為homebrew安裝的路徑。 $which ruby"
  },"/pages/c/basic/block/": {
    "title": "程式碼區塊",
    "keywords": "",
    "url": "/pages/c/basic/block/",
    "body": "一對花括號{}包起來的就是程式碼區塊。程式碼區塊可以是if(){}或while(){}的程式碼區塊，但這篇要探討的是只有花括號{}包起來的程式碼區塊。 區域變數 1 2 3 4 5 6 7 8 9 int main() { int var11 = 100; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 outer var11 = 100 在程式碼區塊中{}，所定義的變數都是區域變數，離開{}區塊就不能再讀取了，因為{}區塊中的區域變數已經被系統回收掉。可以想像{}就像是函式一樣。在函式中，函式中定義的變數都是區域變數，離開函式就不能被外部讀取區域變數，因為區域變數已經被系統回收了。 外部變數 1 2 3 4 5 6 7 8 9 10 11 int main() { int var11 = 100; int var12 = 200; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 注意第7行，在{}區塊中，可以讀取外部變數。 在程式區塊中{}無法讀取同名的外部變數 因為在{}區塊中，同名的外部變數會先被暫時隱藏，直到程式執行時離開{}區塊，區塊內的區域變數被系統回收掉，同名的變數就會將記憶體位置指向外部變數。 程式區塊中{}讀取跟區域變數同名的全域變數 使用::可以讀取全域變數。 1 2 3 4 5 6 7 8 9 10 11 int var11 = 100; int main() { int var12 = 200; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; cout &lt;&lt; \"outer var11 = \" &lt;&lt; ::var11 &lt;&lt; endl; } return 0; } 第1行，定義全域變數var11。 第5行，定義區域變數var11。 第6行，印出區域變數var11。 第8行，印出全域變數var11。 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 for程式區塊中的區域變數 變數i的有效範圍，只有在{}程式區塊中，離開{}程式區塊，區域變數i就無法在外部讀取。 1 2 3 for(int i = 0; i &lt; 10; i++) { } 若要變數i也可以在外部使用，可把變數i放在外部。 1 2 3 4 int i = 0; for(; i &lt; 10; i++) { } cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; 執行結果 i = 10 虛擬碼 可以在程式區塊寫虛擬碼，進行驗證，作為之後正式的函式使用。 以下程式碼是在寫參數為指標，將指標宣告記憶體空間。 1 2 3 4 5 6 7 8 9 10 11 int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 { int** pp = &amp;p;//存放指標的地址，要用雙指標 *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第3行，宣告指標。 第5行，宣告雙指標，存放指標的位址。 第6行，去雙指標pp的記憶體位址取值，取出來是p的指標記憶體位址，使用new來分配動態配置記憶體空間，並且設值”3”，動態配置完成會回傳記憶體位址，由指標去存位址。 第8行，印出p指標的位址，去p指標的記憶體位址取值，並印出來。 執行結果 p=0x60000000c000,*p=3 虛擬碼執行成功後，將{}程式碼區塊移到main()函式之外，並宣告成函式。 1 2 3 4 5 6 7 8 9 10 11 void initMemory(int** pp) //存放指標的地址，要用雙指標 { *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 initMemory(&amp;p);//指標的位址傳入函式。 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 p=0x600000008030,*p=3"
  },"/pages/c/basic/charType/": {
    "title": "char字元",
    "keywords": "",
    "url": "/pages/c/basic/charType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long char char是正整數，雖然顯示是字元，但實際存放在記憶體位置的資料型態是整數。 char所對映的整數是顯示在瑩幕上的ASCII碼。https://zh.wikipedia.org/zh-tw/ASCII 若輸入單引號''包住的字元，編譯器會自動把單引號包住的字元轉成整數。 比如'a'，記憶體位址存放的十進位值是97，二進制是01100001 整數型態 占用Byte數量 數值範圍 格式符 輸出格式 char 1 0~127 %c 字元 char 1 0~127 %d 整數 字元變數賦值數字。 程式碼 1 2 3 char c = 97; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 第一行，直接給整數到c變數。 執行結果 97 a 印出char可用%c或%d 1 2 3 char c = 'a'; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 執行結果 97 a int變數賦值字元。 在c++中，可以直接給int變數賦值單引號''包住的字元 1 2 3 4 5 int main() { int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; c1 &lt;&lt; endl; return 0; } 執行結果 65 int轉型字元 想印出字元，就把int轉型成char 1 2 int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 執行結果 A 字元運算 也可字元加整數做運算。 1 2 int c1 = 'A' + 2; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 第一行，字元+2。 執行結果 c1=C 跳脫字元 重要有以下幾種 Ascii碼 跳脫字元 描述 0 \\0 空，字元變數可設定0 9 \\t TAB鍵對齊 10 \\n 換行 13 \\r 移動到最前面 設定空 1 2 char c4 = 0; cout &lt;&lt; \"c4=\" &lt;&lt; c4 &lt;&lt; endl; 關於斜線 因為\"與'與\\，被編譯器作為以下用途。 \"\"，把字串包起來。 ''，把字元包起來。 \\，換行\\n 所以不能直接使用\"與'與\\，必須加上\\“與\\‘與\\\\。 雙引號 1 2 3 char c2 = '\"'; cout &lt;&lt; \"c2=\" &lt;&lt; c2 &lt;&lt; endl; cout &lt;&lt; \"我說，\\\"跑!\\\"\" &lt;&lt; endl; 第1行，當作字元的雙引號，前面不用加斜線'\\\"'，直接寫雙引號就可以'\"'。 第3行，當作字串中的的雙引號，前面要加斜線。 執行結果 c2=\" 我說，\"跑!\" 單引號 1 2 3 char c3 = '\\''; cout &lt;&lt; \"c3=\" &lt;&lt; c3 &lt;&lt; endl; cout &lt;&lt; \"我說，'跑!'\" &lt;&lt; endl; 第1行，當作字元的單引號，前面要加斜線'\\''。 第3行，當作字串中的的單引號，前面不用加斜線。 執行結果 c3=' 我說，'跑!'"
  },"/pages/c/basic/printformat/": {
    "title": "整數與浮點數",
    "keywords": "",
    "url": "/pages/c/basic/printformat/",
    "body": "整數 整數資料型態 整數型態 占用Byte數量 格式符 取值範圍 int 4 %d -2,147,483,648 至 2,147,483,647 unsinged int 4 %u 0 到 4,294,967,295 short 2 %hd -32,768 至 32,767 unsinged short 2 %hu 0 到 65,535 long 4 %ld -2,147,483,648 至 2,147,483,647 unsinged long 4 %ud 0 到 18,446,744,073,709,551,615 long long 8 %lld -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 unsinged long long 8 %llu 0 到 18,446,744,073,709,551,615 整數相除，去掉小數點，只留正數，不會四捨五入 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; 8/5 &lt;&lt; endl; 執行結果 8/5 = 1 運算式中有低類型與高類型，低類型會自動轉成高類型，不需要手動轉換。 1 2 3 4 char c7 = 97; int i1 = 25; long long llong1 = 150000000000; cout &lt;&lt; \"97 + 25 + 150000000000 = \" &lt;&lt; c7 + i1 + llong1 &lt;&lt; endl; 執行結果 97 + 25 + 150000000000 = 150000000122 等號(=)左邊是高類型，右邊是低類型，低類型會自動轉成高類型，不需要手動轉換。 1 2 3 char c7 = 97; int i2 = c7; cout &lt;&lt; \"i2 = \" &lt;&lt; i2 &lt;&lt; endl; 執行結果 i2 = 97 等號(=)左邊是整數，右邊是浮點數，浮點數小數點直接去掉，轉換成整數。 1 2 int i3 = 23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 等號(=)右邊超出範圍。 unsigned int最大的值是4294967295。 1 2 3 4 5 6 unsigned int ui1 = 4294967295; unsigned int ui2 = 4294967295 + 1; unsigned int ui3 = 4294967295 + 2; cout &lt;&lt; \"ui1 = \" &lt;&lt; ui1 &lt;&lt; endl; cout &lt;&lt; \"ui2 = \" &lt;&lt; ui2 &lt;&lt; endl; cout &lt;&lt; \"ui3 = \" &lt;&lt; ui3 &lt;&lt; endl; 執行結果 ui1 = 4294967295 ui2 = 0 ui3 = 1 unsigned int最大的值是4294967295，若超出的二進制會被去掉。 超出的二進制 二進制 十進制 輸出結果   11111111 11111111 11111111 11111111 4294967295 4294967295 00000001 00000000 00000000 00000000 00000000 4294967295 + 1 0 00000001 00000000 00000000 00000000 00000001 4294967295 + 2 1 強制轉換 使用強制轉換編譯器不會出現警告。 語法 (強制轉換類型)值、變數、常數、運算式 1 2 int i3 = (int)23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 1 cout &lt;&lt; \"(double)8/5 = \" &lt;&lt; (double)8/5 &lt;&lt; endl; 執行結果 (double)8/5 = 1.6 括號的優先級別比較高 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; (double)(8/5) &lt;&lt; endl; 執行結果 8/5 = 1 以上程式碼先執行(8/5)，也就是整數相除會直接去掉小數點，變成1，1再轉成double類型。 整數資料型態都可以使用%d印出，只是印出的精準度不同。 浮點數 浮點數資料型態 有效數字是指準確度的數字，例如float，有7位數字會是正確的，超過7位以上，第8位以後就會不正確。 有效數字範圍:包含小數點前面與後面的所有數字。 浮點數型態 占用Byte數量 格式符 有效數字範圍 float 4 %f 7位有效數字 double 8 %lf 15-16位有效數字 long double 不少於double %Lf 不少於double 數字有小數點就視為double類型 1 2 cout &lt;&lt; \"size of int = \" &lt;&lt; sizeof(8) &lt;&lt; endl; cout &lt;&lt; \"size of double = \" &lt;&lt; sizeof(8.0) &lt;&lt; endl; 執行結果 size of int = 4 size of double = 8 數字最後面有f視作float類型 1 cout &lt;&lt; \"size of float = \" &lt;&lt; sizeof(8.0f) &lt;&lt; endl; 執行結果 size of float = 4 float格式化輸出 1 2 3 float f1 = 3.8f; printf(\"f1 = %f \\n\", f1); printf(\"f1 = %.2f \\n\", f1); 執行結果 f1 = 3.800000 f1 = 3.80 double格式化輸出 1 2 3 4 float f1 = 3.8; double d1 = 3.8; printf(\"f1 = %f , d1 = %f , d1 = %lf\\n\", f1, d1, d1); printf(\"f1 = %.2f , d1 = %.2f , d1 = %.2lf\\n\", f1, d1, d1); 執行結果 f1 = 3.800000 , d1 = 3.800000 , d1 = 3.800000 f1 = 3.80 , d1 = 3.80 , d1 = 3.80 運算式中有浮點數，其它整數會自動轉成浮點數，不需要手動轉換。 1 cout &lt;&lt; \"8.0/5 = \" &lt;&lt; 8.0/5 &lt;&lt; endl; 執行結果 8/5 = 1.6 有效位數 float有效位數 1 2 float f1 = 123456789.123f;//float 有效數字範圍為7位 printf(\"f1 = %f \\n\", f1); 執行結果 f1 = 123456792.000000 從執行結果可以發現第8位以後數字就不正確。 double有效位數 1 2 double d1 = 123456789.123456789; printf(\"d1 = %lf \\n\", d1); 執行結果 d1 = 123456789.123457 從執行結果可以發現小數點第6位以後數字就不正確。 long dobule有效位數 1 2 long double Ld1 = 123456789.123456789; printf(\"Ld1 = %Lf \\n\", Ld1); 執行結果 Ld1 = 123456789.123457 從執行結果可以發現跟double的結果相同，long double取決於系統是Linux/Mac/Windows，會呈現不同結果。"
  },"/pages/c/editor/cmake/": {
    "title": "Cmake on Mac",
    "keywords": "",
    "url": "/pages/c/editor/cmake/",
    "body": "前往下載Cmake 解壓好放在應用程式中 打開CMAKE 按照下圖，選擇Tool-&gt;How to Install For Command Line Use 將以下紅框的部分複製，打開終端機，貼上 貼上後再輸入以下指令 $which cmake 再輸入以下指令 $cmake --version 切記，把版本資訊記起來，如我的版本資訊是cmake version 3.27.5 在你所在.cpp的目錄下建立build目錄 跟build目錄同階層建立CMakeLists.txt的文件 在CMakeLists.txt的文件中輸入以下內容 //VERSION編號是之前查詢的 cmake_minimum_required(VERSION 3.27.5) //第一參數為Project名稱 //Project的版本是1.0.0 project(CPPLessons VERSION 1.0.0) //第一個參數是Project名稱 第二個參數為所使用的cpp add_executable(CPPLessons test.cpp Student.cpp) 建立檔案，依xcode為例，在工作列按滑鼠右鍵，選”New File” 依照下圖建立頭文件 再來建立cpp文件 記得不要勾選要建立頭文件 在test.cpp輸入以下內容 1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; #include \"test.h\" int main() { int a[] = {1,2,3,4}; printf(\"cmake test\"); int b[] = {7,8,9,100}; printf(\"cmake test2\"); return 0; } 打開終端機，進入build的目錄 輸入以下內容(要在build的目錄下做喔) cmake .. 產生以下資訊 輸入make make 輸入./CPPLessons 測試成功"
  },"/pages/c/editor/supportc11/": {
    "title": "Xcode支援C++11以上",
    "keywords": "",
    "url": "/pages/c/editor/supportc11/",
    "body": "選擇專案名 選擇Build Settings 選擇Apple Clang 選擇C++ Language Dialect"
  },"/pages/c/editor/vscode/": {
    "title": "VS Code on Mac",
    "keywords": "",
    "url": "/pages/c/editor/vscode/",
    "body": "可以參考其它人的影音檔。 https://www.youtube.com/watch?v=iIPST6HQgSc 參考文章 Visual Studio Code on macOS Using Clang in Visual Studio Code 若code .沒反應 “code .” is not working in on the command line for Visual Studio Code on OS X/Mac"
  },"/pages/c/template/classTemplate/": {
    "title": "類別模板",
    "keywords": "",
    "url": "/pages/c/template/classTemplate/",
    "body": "語法 宣告模板 宣告型別參數 型別參數名 逗號 template &lt; class T1 , class T2&gt; 宣告模板從關鍵字template開始，後接型別參數列表（template parameter list），型別參數是以class開頭，後接型別參數名(T1)。型別參數列表是用尖括號括住的一個型別參數或者多個型別參數，型別參數之間以逗號分隔。class也可以用typename互相替換。 宣告類別模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template &lt;class K, class V&gt; class MyMap{ public: MyMap(){} MyMap(K key1, V value1):key(key1),value(value1){} K getKey(){ return key; } V getValue(){ return value; } private: K key; V value; }; 第1行，template為類別模板宣告，&lt;class K, class V&gt;型別參數宣告(type parameter)。 第2行，類別模板的名稱為MyMap。 第5行，建構式，初始私有成員key與value。 第6行，取得私有成員key。 第9行，取得私有成員value。 第13行，私有成員key。 第14行，私有成員value。 使用類別模板 1 2 3 4 5 6 7 8 9 10 int main() { MyMap&lt;int,string&gt; myMap(3, \"test\"); cout &lt;&lt; \"myMap key=\" &lt;&lt; myMap.getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap value=\" &lt;&lt; myMap.getValue() &lt;&lt; endl; MyMap&lt;string, string&gt; *myMap_P1 = new MyMap&lt;string,string&gt;(\"abc\",\"def\"); cout &lt;&lt; \"myMap_P1 key=\" &lt;&lt; myMap_P1-&gt;getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap_P1 value=\" &lt;&lt; myMap_P1-&gt;getValue() &lt;&lt; endl; return 0; } 第2行，建立物件，用尖括號&lt;K,V&gt; 指定參數型別，K的型別為int，V的型別為string，呼叫二個參數的建構式。 第3行，印出值。 第4行，印出值。 第6行，動態配置建立物件，用尖括號&lt;K,V&gt; 指定參數型別，K的型別為string，V的型別為string，使用new動態配置建立物件，( “abc”,”def”)呼叫二個參數的建構式。 第7行，使用-&gt;印出值。 第8行，使用-&gt;印印出值。"
  },"/pages/c/template/funTemplate/": {
    "title": "函式模板",
    "keywords": "",
    "url": "/pages/c/template/funTemplate/",
    "body": "模板定義 宣告模板 宣告型別參數 型別參數名字 逗號 template &lt; class T1 , class T2&gt;"
  },"/pages/c/template/stackTemplate/": {
    "title": "Stack實作(int Array)",
    "keywords": "",
    "url": "/pages/c/template/stackTemplate/",
    "body": "Stack int陣列實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Stack{ private: int *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new int[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const int&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(int&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; 第3行，私有成員屬性items，類型為int指標，指向int陣列的第0筆地址。 第4行，私有成員屬性stacksize，型別為int，存放stack最大的容量。 第5行，私有成員屬性top，型別為int，記錄目前stack最頂端的index位置。 第8行，建構式，初始化成員stacksize與top。 第10行，動態配置int陣列。 第12行，解構式。 第13行，從記憶體釋放items的空間。 第14行，將釋放的空間指向null。 第20行，若top位置在0，表示為空。 第25行，若top位置在stacksize代表空間已滿。 第31行，函式是將item推入stack，參數為參考型別。 第33行，目前stack最頂端的index位置小於stack最大容量就做if的區塊。 第34行，先做items[top] = item的動作，再做top++的動作。 第42行，參數為參考型別，stack彈出頂端的值暫時放置的變數。 第44行，先將top–的動作，再做items[top]的動作。 使用Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } 第2行，建立stack物件，最大存放數量為5。 第3~7行，依序塞入1~5。 第8行，宣告暫時存放變數item。 第9行，若stack不為空就進入循環。 第10行，將stack的頂端拿出來，放在變數item。 第11行，印出item。 執行結果 item = 5 item = 4 item = 3 item = 2 item = 1 Stack typedef實作 將上面的程式修改成自定義型別DataType。以下有黃色的部分是有變更的程式碼。 typedef int DataType; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); DataType item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } Stack 模板實作 將上面的程式再修改成模板，以下有黃色的部分是有變更的程式碼。 template &lt;class DataType&gt; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack&lt;int&gt; myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; }"
  },"/pages/c/basic/typicalRange/": {
    "title": "資料型別範圍",
    "keywords": "",
    "url": "/pages/c/basic/typicalRange/",
    "body": "記憶體的最小單位為bit，每一個bit可以存0或1，32位元電腦的cpu有32個bit(4byte)的存放區塊可以存放記憶體位址。 位元bit與位元組byte bit正整數範圍 以下列出1到8個bit可以存放的最大正整數值與正整數範圍。 bit 組合 最大正整數(2進制) 最大正整數(10進制) 可以存放的正整數範圍 1 0/1 1 \\(2^1-1 = 1\\) 0-1 2 00/01/10/11 11 \\(2^2-1 = 3\\) 0-3 3 000/001/010/100/110/101/111 111 \\(2^3-1 = 7\\) 0-7 4 0000/0001/0010…1111 1111 \\(2^4-1 = 15\\) 0-15 5 00000/00001/…11111 11111 \\(2^5-1 = 31\\) 0-31 6 000000/000001/…111111 111111 \\(2^6-1 = 63\\) 0-63 7 0000000/0000001/…1111111 1111111 \\(2^7-1 = 127\\) 0-127 8 00000000/00000001/…11111111 11111111 \\(2^8-1 = 255\\) 0-255 byte正整數範圍 由上表可以推斷，1個byte由8個bit組成，可存放最大正整數為255，可以存放的正整數範圍從0-255，共256個數字。 以下列出1byte到4byte最大可存放的數字。 byte bit 最大正整數(10進制) 1byte 11111111 255 2byte 11111111 11111111 65535 3byte 11111111 11111111 11111111 16777216 4byte 11111111 11111111 11111111 11111111 4294967295 科學記號法顯示 byte bit 科學記號法 1byte 11111111 $2^8-1$ 2byte 11111111 11111111 $2^8 * 2^8 -1= 2^{8+8}-1 = 2 ^{16}-1 $ 3byte 11111111 11111111 11111111 $2^8 * 2^8 * 2^8-1 = 2^{8+8+8}-1$ 4byte 11111111 11111111 11111111 11111111 $2^8 * 2^8 * 2^8 * 2^8-1 = 2^{8+8+8+8}-1 = 2 ^{32}-1 $ 正負數 若資料型態是包含正負數，會將最大整數減半，一半分給正數，一半分給負數。最左邊的第1個bit就會變成正負號，0為正數，1為負數。負數的二進制顯示方式為把正數的二進制0和1互換，最後再加1。 正負數 二進位 正負數 01111111 127 10000001 -127 01111111 11111111 32767 10000000 00000001 -32768 01111111 11111111 11111111 8388607 10000000 00000000 00000001 -8388608 01111111 11111111 11111111 11111111 2147483647 10000000 00000000 00000000 00000001 -2147483648 正負數範圍 占用Byte數量 正負數範圍 1byte -128~127 2byte -32768~32767 3byte -8388608~8388607 4byte -2147483648~2147483647 unsinged正整數 unsigned代表沒有符號，所以只有正整數，不會有負號。 占用Byte數量 正數範圍 1byte 0~255 2byte 0~65535 3byte 0~16777216 4byte 0~4294967295"
  },"/pages/c/basic/boolType/": {
    "title": "bool",
    "keywords": "",
    "url": "/pages/c/basic/boolType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long 整數型態 占用Byte數量 數值範圍 格式符 輸出格式 bool 1 0 1 %d 整數 0是false，非0為true。 1 2 3 bool b3 = '0'; bool b4 = 0; cout &lt;&lt; \"b3=\" &lt;&lt; b3 &lt;&lt; \",b4=\" &lt;&lt; b4 &lt;&lt; endl; 執行結果 b3=1,b4=0 可使用true跟false設定bool變數 編譯器會自動把true翻譯成整數1，false翻譯成整數0。 1 2 bool b1 = true, b2 = false; cout &lt;&lt; \"b1=\" &lt;&lt; b1 &lt;&lt; \",b2=\" &lt;&lt; b2 &lt;&lt; endl; 執行結果 b1=1,b2=0 bool整數運算 因為bool是整數，所以bool能做整數運算。但bool顯示出來只會是0或1，即便設的值是2，顯示出來的值仍是1。 1 2 3 4 bool b5 = 1; bool b6 = 2; cout &lt;&lt; \"b5 = \" &lt;&lt; b5 &lt;&lt; \", b6 = \" &lt;&lt; b6 &lt;&lt; endl; cout &lt;&lt; \"b5 + b6 = \" &lt;&lt; b5 + b6 &lt;&lt; endl; 執行結果 b5 = 1, b6 = 1 b5 + b6 = 2 cin只能輸0或1，不能輸入true或false 1 2 3 bool b7; cin &gt;&gt; b7; cout &lt;&lt; \"b7 = \" &lt;&lt; b7 &lt;&lt; endl; 執行結果 1 b7 = 1 執行結果 true b7 = 0 證明bool為整數 1 2 3 4 bool b8 = false; char* c5 = (char*)&amp;b8; *c5 = 8; cout &lt;&lt; \"b8 = \" &lt;&lt; b8 &lt;&lt; endl;"
  },"/pages/c/pointer/memoryLayout/": {
    "title": "記憶體配置",
    "keywords": "",
    "url": "/pages/c/pointer/memoryLayout/",
    "body": "記憶體起始與結束地址。 記憶體開始地址由下表最下方開始，記憶體結束地址在最上方。 開始與結束 地址高低 地址 結束 高 0xFFFFFFFF 0xFFFFFFFE 0xFFFFFFFD 0xFFFFFFFC &#8593; ...... ...... ...... ...... 低 0x00000004 0x00000002 0x00000001 開始0x00000000 記憶體區段 記憶體區段根據地址由高到低分別為Kernel, Stack, 尚位使用區域, Heap, bass, data, code。 地址高低 區段 地址增長方向 儲存項目 高 Kernel 內核 &#8593; Stack &#8595; 區域變數 尚未使用區域 Heap &#8593; 動態分配指標 bss segmen 未初始化全域變數, 靜態變數 data segmen 已初始化全域變數, 靜態變數 低 code segment 常數與程式執行檔 內核 處理cpu記憶體Devices與應用程式運作。 stack 函式或程式區塊{}中區域變數與函式參數與函式返回值的記憶體地址。 Heap 動態分配指標記憶體地址 bss 未初始化全域變數與靜態變數記憶體地址 data segmen 已初始化全域變數與靜態變數記憶體地址 code segment 常數與程式執行檔地址 變數記憶體位址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;stdio.h&gt; const int global_x = 1; // 儲存於 code segment(常數) int global_y = 1; // 儲存於 data segmen(已初始化全域變數） int global_z; // 儲存於 bss(未初始全域變數) int fun1(int param1) { // 儲存於 stack (函式參數) return param1; // 儲存於 stack (函式返回值) } int main() { const static int x = 1; // 儲存於 code segment(常數) static int y = 1; // 儲存於 data segmen(已初始化靜態變數） static int z; // 儲存於 bss(未初始靜態變數) int w = 1; // 儲存於 stack (區域變數) fun1(w); // 儲存於 heap (動態分配指標) char *buf = (char*) malloc(sizeof(char) * 100); // ... free(buf); int* p = new int(3); // 儲存於 heap (動態分配指標) delete p; return 0; } Stack 儲存在Stack的變數，變數離開有效範圍(Scope)後，會由系統自動釋放記憶體地址。 Stack記憶體容量8M。 記憶體地址向下遞減。 不會memory leak。 以下程式碼在函式中建立三個變數，並觀察三個變數的記憶體地址是由大至小遞減。證明記憶體地址向下遞減。 1 2 3 4 5 6 7 8 void funcMemoryLocation() { int var1 = 10; int var2 = 20; int var3 = 30; cout &lt;&lt; \"va1 = \" &lt;&lt; (long long)&amp;var1 &lt;&lt; endl; cout &lt;&lt; \"va2 = \" &lt;&lt; (long long)&amp;var2 &lt;&lt; endl; cout &lt;&lt; \"va3 = \" &lt;&lt; (long long)&amp;var3 &lt;&lt; endl; } 執行結果 va1 = 140702053822444 va2 = 140702053822440 va3 = 140702053822436 Heap 儲存在Heap的指標，由程式設計師手動釋放記憶體地址，或待主程式生命周期結束後被系統釋放記憶體地址。 Heap記憶體容量取決於電腦的記憶體大小。 記憶體地址向上遞增。 會memory leak。 以下程式碼動態分配指標建立三個變數，並觀察三個變數的記憶體地址是由小至大增長。證明動態分配記憶體地址向上遞增。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int* p1 = new int(10); int* p2 = new int(20); int* p3 = new int(30); cout &lt;&lt; \"p1 address = \" &lt;&lt; (long long)p1 &lt;&lt; endl; cout &lt;&lt; \"p2 address = \" &lt;&lt; (long long)p2 &lt;&lt; endl; cout &lt;&lt; \"p3 address = \" &lt;&lt; (long long)p3 &lt;&lt; endl; delete p1; delete p2; delete p3; p1 = nullptr; p2 = nullptr; p3 = nullptr; return 0; } 執行結果 p1 address = 105553116315664 p2 address = 105553116315680 p3 address = 105553116315696 尚未使用區域 變數在Stack區段中，地址增長的方向是向下遞減，變數在Heap區段中，地址增長的方向是向上遞增，未避免Stack與Heap的記憶體地址互相交疊，中間有一個區域是分隔Stack與Heap。"
  },"/pages/c/conversion/explicit/": {
    "title": "強制轉型",
    "keywords": "",
    "url": "/pages/c/conversion/explicit/",
    "body": "將等號(=)右邊的值強制轉型，明確告訴編譯器等號(=)右邊的值的類型。 1 int a = (int)8.3; 另一種強制轉型的方式，將值放在括號中()。 1 int a = int(8.3);"
  },"/pages/c/conversion/implicit/": {
    "title": "隱式轉型",
    "keywords": "",
    "url": "/pages/c/conversion/implicit/",
    "body": "編譯器根據等號(=)左邊的變數類型，決定調用那個轉換函式。 1 int a = 8.3; 等號(=)左邊的變數類型是int，等號(=)右邊的值是double，編譯器根據等號(=)左邊的變數類型int，把等號(=)右邊的類型double轉成int。"
  },"/pages/c/pointer/pointer/": {
    "title": "指標基本觀念",
    "keywords": "",
    "url": "/pages/c/pointer/pointer/",
    "body": "變數地址 每個變數系統會分配”一塊”記憶體地址存放變數，地址通常是用16進制表示。 變數占用的記憶體大小，根據變數的類型決定。 假設有一個int類型的變數i，占用記憶體4 byte，變數i占的開始地址0x00000008至結束地址0x0000000B，總共占4Byte。 int i = 55; 記憶體開始與結束記憶體地址占用記憶體地址範圍 結束0xFFFFFFFF &#8593;...... 0x0000000E 0x0000000D 0x0000000C 0x0000000Bint i = 55; 0x0000000A 0x00000009 0x00000008 0x00000007 0x00000006 0x00000005 0x00000004 0x00000003 0x00000002 0x00000001 開始0x00000000 取出變數的開始記憶體地址 取地址運算子&amp; &amp;變數 在變數前面加上&amp;可以取出變數的開始記憶體地址，如上一個表格中的例子，變數i的開始地址是0x00000008。 1 2 3 4 5 6 7 int main() { int a = 0; double b = 10.5; cout &lt;&lt; \"變數a地址 = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"變數b地址 = \" &lt;&lt; &amp;b &lt;&lt; endl; return 0; } 執行結果 變數a地址 = 0x7ff7bfeff468 變數b地址 = 0x7ff7bfeff460 指標是一種變數，存放的內容是地址。 以下為宣告一個i1的整型變數，初始值為10。 1 int i1 = 10; 指標變數存放的內容是地址，以下為宣告一個p1的指標變數，存放i1的開始地址。 1 int* p1 = &amp;i1; 指標的大小8byte 指標變數的大小8byte，使用sizeof(指標變數)可以取得指標的大小，不管是什麼類型的指標，佔用記憶體的大小全部為8byte。 1 cout &lt;&lt; sizeof(p1) &lt;&lt; endl; 執行結果 8 地址放入指標變數 指標存放的內容是地址，所以要先取得變數的開始地址，再放入指標變數中，使用&amp;可以取得變數開始地址。 1 2 3 4 5 6 7 int main() { int i1 = 10; int* p1 = &amp;i1; cout &lt;&lt; \"i1的地址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的地址 =\" &lt;&lt; p1 &lt;&lt; endl; return 0; } 第2行，宣告i1整型變數。 第3行，宣告p1整型指標變數，使用取地址運算子&amp;，取出i1變數的記憶體開始地址，將地址放入p1指標。 第4行，印出i1的地址。 第5行，印出p1所存放的內容。 執行結果 i1的地址=0x7ff7bfeff468 p1存放的地址 =0x7ff7bfeff468 從執行結果可以發現，印出的結果是一樣。 宣告指標的各種寫法 宣告指標可以把*放置在變數前面或類型後面或類型與變數中間，以下都是正確的。 1 2 3 4 5 6 7 8 9 10 11 int main() { int i1 = 10; int *p1 = &amp;i1; //*在變數前面 int* p2 = &amp;i1; //*在類型後面 int * p3 = &amp;i1; //*在類型與變數中間 cout &lt;&lt; \"i1的地址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的地址 =\" &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; \"p2存放的地址 =\" &lt;&lt; p2 &lt;&lt; endl; cout &lt;&lt; \"p3存放的地址 =\" &lt;&lt; p3 &lt;&lt; endl; return 0; } 執行結果 i1的地址=0x7ff7bfeff468 p1存放的地址 =0x7ff7bfeff468 p2存放的地址 =0x7ff7bfeff468 p3存放的地址 =0x7ff7bfeff468 取值運算子* 取值運算子*是取得地址中存放的值。指標存放地址，指標也就等於地址。 *指標 以上語法為，取出地址中存放的值，而指標就是地址。 1 2 3 4 5 6 int main() { int i1 = 10; int *p1 = &amp;i1; //將i1變數的地址存到p1指標變數 cout &lt;&lt; \"取出p1地址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; //取出地址存放的值。 return 0; } 執行結果 取出p1地址的值 = 10 修改地址存放的值* *指標 = 修改的內容 把*放在指標變數前面，就可以在等於(=)後面放入要修改的內容。 1 2 3 4 5 6 7 8 9 10 int main() { int i1 = 10; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; int *p1 = &amp;i1; cout &lt;&lt; \"取出p1地址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; *p1 = 20; cout &lt;&lt; \"取出p1地址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; return 0; } 第6行，把*放在指標變數p1前面，等於(=)後面放入要修改的內容20。 執行結果 取出i1的值 = 10 取出p1地址的值 = 10 取出p1地址的值 = 20 指標類型要與值一致。 指標是存放地址，不能存放不是地址的值，會編譯錯誤。 1 2 3 4 5 int main() { int i1 = 10; int *p1 = i1; return 0; } 第2行，i1變數是整數10。 第3行，把10塞入指標，因為指標是存放地址，不能放10這個整數，產生編譯錯誤。 印出地址 十六進制 以下的方式印不出char變數的地址。 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c地址 = \" &lt;&lt; &amp;c &lt;&lt; endl; return 0; } 執行結果 變數c地址 = a 使用(void*)就可以印出16進制的地址 (void*)指標變數 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c地址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 執行結果 變數c地址 = 0x7ff7bfeff46b 十進制 (long long)指標變數 因為int只有4byte，地址轉成int整數會超出範圍，使用long long 8byte，就不會有超出數值範圍的問題。 c語言 printf(\"%#x\",指標變數); 使用%#x就可印出16進制的記憶體地址。 程式碼範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int i1 = 10; int *p1 = &amp;i1; cout &lt;&lt; \"16進制 &amp;i1 = \" &lt;&lt; (void*)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"16進制 p1 = \" &lt;&lt; (void*)p1 &lt;&lt; endl; cout &lt;&lt; \"10進制 &amp;i1 = \" &lt;&lt; (long long)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"10進制 p1 = \" &lt;&lt; (long long)p1 &lt;&lt; endl; printf(\"c語言 &amp;i1 = %#x \\n\",&amp;i1); printf(\"c語言 p1 = %#x \\n\",p1); return 0; } 執行結果 16進制 &amp;i1 = 0x7ff7bfeff468 16進制 p1 = 0x7ff7bfeff468 10進制 &amp;i1 = 140702053823592 10進制 p1 = 140702053823592 c語言 &amp;i1 = 0xbfeff468 c語言 p1 = 0xbfeff468 指標類型 指標的類型要與記憶體地址中的內容相符。 1 2 3 4 int i = 10; int* p1 = &amp;i; double d = 15.5; double* p2 = &amp;d;"
  },"/pages/c/pointer/pointerConst/": {
    "title": "const與指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerConst/",
    "body": "以下二種十分容易混淆，而且十分難記。 Pointer to Const (const*) const右邊是星號* 代表指標地址中的內容是常數，常數不能修改，以下語法不能使用。 *指標 = 修改的內容 1 2 3 4 5 6 7 int main() { int var1 = 10; int const * p = &amp;var1; //*p = 11; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，變數名var1。 第3行，將var1的地址給指標變數p。 第4行，p指標地址中的內容是常數，常數不能修改，所以不能使用*指標 = 修改的內容，此行必須註解，因為會產生編譯錯誤。 第6行，印出var1的值與p指標地址中的值。 執行結果 var1=10,p=10 int const * p可以更改成const int* p，二者為一樣的意思，只要記得const右邊若先出現星號*而不是變數名，代表指標地址中的內容是常數，常數沒有辦法修改。 1 2 3 4 5 6 int main() { int var1 = 10; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第3行，int const * p可以更改成const int* p。 可以修改指標地址 1 2 3 4 5 6 7 8 9 int main() { int var1 = 10; int var2 = 20; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; p = &amp;var2; cout &lt;&lt; \"var2=\" &lt;&lt; var2 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，第3行，建立二個變數名var1與var2。 第4行，將var1的地址給指標p。 第6行，將var2的地址給指標p。 執行結果 var1=10,p=10 var2=20,p=20 Const Pointer (const 指標名) const右邊是指標名 代表指標名是常數，需要初始化常數名(初始化設地址)，不能再更改指標地址。 1 2 3 4 5 6 7 8 int main() { int var1 = 10; int var2 = 11; int* const p = &amp;var1; //p = &amp;var2; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，第3行，建立二個變數名var1與var2。 第4行，const右邊是指標名p，代表指標名p是常數，常數需要初始化，不能是nullptr，將var1的地址給指標p。 第5行，將var2的地址給指標p，會編譯失敗，因為指標p是常數，不能被修改地址。 可以修改內容 可使用*指標 = 修改的內容修改指標地址的值，因為只有指標名是常數，不能變更初始地址，但指標地址中的內容並非常數，所以可以改變指標地址中的內容。 1 2 3 4 5 6 7 int main() { int var1 = 10; int* const p = &amp;var1; *p = 55; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=55,p=55"
  },"/pages/c/pointer/pointerParam/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerParam/",
    "body": "引數與參數 引數 Argument 傳給函式的變數。 1 2 3 4 5 int main() { int var1 = 10; func1(var1); return 0; } 第3行，將var1傳到func1()函式中，而var1就是引數Argument。 台灣稱Argument為引數。 大陸稱Argument為實參。 參數 Parameter 函式接收到的變數。 1 2 3 void func1(int param1) { cout &lt;&lt; \"param1=\" &lt;&lt; param1 &lt;&lt; endl; } 第1行，函式接收到來自外面傳進來的變數，變數名param1，而param1就是參數。 台灣稱Parameter為參數。 大陸稱Parameter為形參。 修改傳進來的參數 指標參數 函式的參數是指標，代表參數是地址。指標參數語法為類型* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是地址，代表可以透過取值運算子*,取出地址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(地址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 第1行，函式的參數是指標，代表參數是地址。 第2行，透過取值運算子*,取出地址存放的內容。 第3行，使用*指標 = 修改內容，修改指標的內容。 第8行，使用取地址運算子&amp;，取出var1變數的記憶體開始地址，將地址作為引數Argument傳進函式fun1()。 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把地址&amp;var1傳進函式，下面的程式碼是先將地址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式返回值 如果有一個功能要求函式返回多個值，只有一個函式返回值根本不夠用，可以把參數作為返回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; using namespace std; class Student { public: Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: string name; double mathScore; double engScore; double historyScore; }; void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); compare(studentArr, 3, mathMax, engMax, historyMax); cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; return 0; } 第2行，宣告Student類別。 第4行，Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore。 第7,10,13,16行，取出name, mathScore, engScore, historyScore公有方法。 第20,21,22,23行，私有成員屬性name, mathScore, engScore, historyScore。 第26行，宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 第29,31,33行，找出數學/英文/歷史最大的分數。 第39行，建立3個學生物件，利用名字,數學英文歷史成績建立物件。 第44,45,46行，宣告三個存最大數學/英文/歷史成績的指標。 第47,將Student陣列，陣列大小，最大數學/英文/歷史成績的指標傳入getMax函式。 第48,49,50行，印出各科最大分數。 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/basic/simpleTraditionC/": {
    "title": "台陸指標相關名詞差異",
    "keywords": "",
    "url": "/pages/c/basic/simpleTraditionC/",
    "body": "英文 台灣 大陸 Data 資料 數據 Data Type 資料型別 數據類 int 整型 整數 char 字元 字符 string 字串 字符串 Byte 位元組 字節 bit 位元 位 %d %s 格式符 占位符 For Loop 巢狀 嵌套 Pointer 指標 指針 ** 指標的指標 二級指針 Function 函式 函數 Variable 變數 變量 Constant 常數 常量 Pointer to Const   常量指針 Const Pointer   指針常量 Local Variable 區域變數 局部變量 Global Variable 全域變數 全局變量 Expression 運算式 表達式 Template 樣板 模板 Argument 引數 實參 Parameter 參數 形參 Memory 記憶體 內存 Dynamic memory allocation 動態配置記憶體 動態內存分配 Stack 堆疊 棧 Heap 堆積 堆 * 取值運算子 解引用運算符 &amp; 取地址運算子 取址運算符 &amp;Reference 參考 引用 default 預設值 缺省 head file 表頭檔 頭文件 cpp file 原始檔 源代碼 Array 陣列 數組 define 宣告 聲明 assign = 設值 賦值 constructor 建構式或建構子 構造方法 deconstructor 解構式或解構子 析構方法或析構函數 conversion 轉型 轉換 explicit conversion 強制轉型 顯示轉換 implicit conversion 自動轉型 隱式轉換"
  },"/pages/c/pointer/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/pointer/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會回傳記憶體占用的開始地址。 類型* 指標變數 = new 類型(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"地址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"地址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 地址是 = 0x600000004010 地址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行釋放，否則會產生memory leak，記憶體一直沒被釋放，記憶體愈占愈多，最後就會當機。 釋放記憶體地址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何地址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/nullptr/": {
    "title": "0 == nullptr == NULL",
    "keywords": "",
    "url": "/pages/c/pointer/nullptr/",
    "body": ""
  },"/pages/c/pointer/pointerVoid/": {
    "title": "void*任何類型的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerVoid/",
    "body": "函式的參數為void*指標(地址) 函式的參數為void*指標，表示任何類型的指標(地址)都可以傳進函式，而且不需要轉型。 1 2 3 4 5 6 7 8 9 10 11 12 void printAddr(void* p) { cout &lt;&lt; p &lt;&lt; endl; } int main() { int i = 10; printAddr(&amp;i); char c = 'a'; printAddr(&amp;c); double d = 150.222; printAddr(&amp;d); return 0; } 第1行，宣告printAddr的函式，參數類型為void*指標。 第2行，印出地址。 第6行，將整數i變數的地址傳入。 第8行，將字元c變數的地址傳入。 第10行，將浮點數d變數的地址傳入。 執行結果 0x7ff7bfeff468 0x7ff7bfeff467 0x7ff7bfeff458 函式返回值為void*指標 表示可以回傳任何類型的指標(地址)，可以轉型成任何類型指標。 以下為malloc的回傳類型void指標(地址)，void指標可以轉成任何類型指標，參數size_t __size代表設定空間大小。 1 void* malloc(size_t __size) 使用方式 在heap區段，建立10 byte的記憶體空間，將回傳的地址轉成char類型的指標。 1 char *name = (char *)malloc(10);//10byte 在heap區段，建立1mb的記憶體空間，將回傳的地址轉成int類型的指標。 1 int *num = (int *)malloc(1 * 1024 * 1024);//1byte*1024 = 1kb -&gt;1kb*1024=1mb 不能對void*指標使用取值運算子* 不能對void*指標使用取值運算子*，需要轉換成其它類型的指標才可以使用取值運算子* 1 2 3 void printAddr(void* p) { cout &lt;&lt; *p &lt;&lt; endl; } 第2行，編譯失敗，不能對p指標使用取值運算子，因為它是void指標類型，必須轉型後才能對指標取出內容。 1 2 3 4 5 6 7 8 void printAddr(void* p) { cout &lt;&lt; *(char*)p &lt;&lt; endl; } int main() { char c = 'a'; printAddr(&amp;c); return 0; } 第2行，先將p指標轉型成char*指標，接著使用取值運算子*取出指標地址中的內容。 執行結果 a 函式的參數為void 函式的參數為void，代表不接受任何參數。 rand()產生亂數，以下為rand函式的定義，不接受任何參數，回傳int 1 int rand (void); 產生0-100的亂數 1 2 int num = rand()%100; printf(\"rand = %d \\n\", num);"
  }}
