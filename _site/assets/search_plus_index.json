{"/blog/pages/c/editor/xcode/": {
    "title": "Xcode",
    "keywords": "",
    "url": "/blog/pages/c/editor/xcode/",
    "body": "輸入Project的名字 選擇要放置的位置，並點選New Folder 輸入新目錄的名稱 要勾不勾git自行決定，按create 點擊main，再按下執行的按鈕"
  },"/blog/pages/jekyll/install/how_to_install_ruby/": {
    "title": "安裝 Ruby on Mac",
    "keywords": "",
    "url": "/blog/pages/jekyll/install/how_to_install_ruby/",
    "body": "打開終端機，輸入下面指令 $brew install ruby 檢查安裝路徑 $brew list ruby homebrew安裝ruby的路徑列表，注意版號是否為3.0以上，目前是3.3.0。 /usr/local/Cellar/ruby/3.3.0/bin/bundle /usr/local/Cellar/ruby/3.3.0/bin/bundler /usr/local/Cellar/ruby/3.3.0/bin/erb /usr/local/Cellar/ruby/3.3.0/bin/gem /usr/local/Cellar/ruby/3.3.0/bin/irb /usr/local/Cellar/ruby/3.3.0/bin/racc /usr/local/Cellar/ruby/3.3.0/bin/rake /usr/local/Cellar/ruby/3.3.0/bin/rbs /usr/local/Cellar/ruby/3.3.0/bin/rdbg /usr/local/Cellar/ruby/3.3.0/bin/rdoc /usr/local/Cellar/ruby/3.3.0/bin/ri /usr/local/Cellar/ruby/3.3.0/bin/ruby /usr/local/Cellar/ruby/3.3.0/bin/syntax_suggest /usr/local/Cellar/ruby/3.3.0/bin/typeprof /usr/local/Cellar/ruby/3.3.0/include/ruby-3.3.0/ (191 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.3.3.dylib /usr/local/Cellar/ruby/3.3.0/lib/pkgconfig/ruby-3.3.pc /usr/local/Cellar/ruby/3.3.0/lib/ruby/ (4276 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.dylib /usr/local/Cellar/ruby/3.3.0/libexec/gembin/ (2 files) /usr/local/Cellar/ruby/3.3.0/share/emacs/site-lisp/ruby/ruby-style.el /usr/local/Cellar/ruby/3.3.0/share/man/ (4 files) /usr/local/Cellar/ruby/3.3.0/share/ri/ (15158 files) 檢查本機ruby的安裝的位置是否與homebrew一致。 $which ruby 我的mac顯示的位置是∶ /usr/bin/ruby 顯然是不一樣，修改環境變數。 $vi ~/.zshrc 添加homebrew 安裝ruby的路徑，注意!以下的位置是你的brew list ruby的路徑，不能直接拷貝我的。 export PATH=\"/usr/local/Cellar/ruby/3.3.0/bin:$PATH\" 修改完.zshrc檔案，在終端機執行以下指令。 $source ~/.zshrc 檢查ruby的路徑是否為homebrew安裝的路徑。 $which ruby"
  },"/blog/pages/c/basic/printformat/": {
    "title": "printf格式化輸出",
    "keywords": "",
    "url": "/blog/pages/c/basic/printformat/",
    "body": "資料型態 整數 有正負整數資料型態 整數型態 byte 格式符 int 4 %d short 2 %hd long 4 %ld Unsigned正整數資料型態 Unsinged代表只有正數。 整數型態 byte 格式符 unsinged int 4 %u unsinged short 2 %hu unsinged long 4 %ud char資料型態 整數型態 byte 格式符 輸出格式 char 1 %c 字元 char 1 %d 整數 印出char可用%c或%d 1 2 3 char c = 'a'; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 執行結果 97 a 以上表格列出的整數資料型態都可以使用%d印出，只是印出的精準度不同。 浮點數 浮點數資料型態 浮點數型態 byte 格式符 float 4 %f double 8 %lf long double 8 %Lf float格式化輸出 1 2 3 float f1 = 3.8; printf(\"f1 = %f \\n\", f1); printf(\"f1 = %.2f \\n\", f1); 執行結果 f1 = 3.800000 f1 = 3.80 double格式化輸出 1 2 3 4 float f1 = 3.8; double d1 = 3.8; printf(\"f1 = %f , d1 = %f , d1 = %lf\\n\", f1, d1, d1); printf(\"f1 = %.2f , d1 = %.2f , d1 = %.2lf\\n\", f1, d1, d1); 執行結果 f1 = 3.800000 , d1 = 3.800000 , d1 = 3.800000 f1 = 3.80 , d1 = 3.80 , d1 = 3.80"
  },"/blog/pages/c/editor/cmake/": {
    "title": "Cmake on Mac",
    "keywords": "",
    "url": "/blog/pages/c/editor/cmake/",
    "body": "前往下載Cmake 解壓好放在應用程式中 打開CMAKE 按照下圖，選擇Tool-&gt;How to Install For Command Line Use 將以下紅框的部分複製，打開終端機，貼上 貼上後再輸入以下指令 $which cmake 再輸入以下指令 $cmake --version 切記，把版本資訊記起來，如我的版本資訊是cmake version 3.27.5 在你所在.cpp的目錄下建立build目錄 跟build目錄同階層建立CMakeLists.txt的文件 在CMakeLists.txt的文件中輸入以下內容 //VERSION編號是之前查詢的 cmake_minimum_required(VERSION 3.27.5) //第一參數為Project名稱 //Project的版本是1.0.0 project(CPPLessons VERSION 1.0.0) //第一個參數是Project名稱 第二個參數為所使用的cpp add_executable(CPPLessons test.cpp Student.cpp) 建立檔案，依xcode為例，在工作列按滑鼠右鍵，選”New File” 依照下圖建立頭文件 再來建立cpp文件 記得不要勾選要建立頭文件 在test.cpp輸入以下內容 1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; #include \"test.h\" int main() { int a[] = {1,2,3,4}; printf(\"cmake test\"); int b[] = {7,8,9,100}; printf(\"cmake test2\"); return 0; } 打開終端機，進入build的目錄 輸入以下內容(要在build的目錄下做喔) cmake .. 產生以下資訊 輸入make make 輸入./CPPLessons 測試成功"
  },"/blog/pages/c/editor/supportc11/": {
    "title": "Xcode支援C++11以上",
    "keywords": "",
    "url": "/blog/pages/c/editor/supportc11/",
    "body": "選擇專案名 選擇Build Settings 選擇Apple Clang 選擇C++ Language Dialect"
  },"/blog/pages/c/editor/vscode/": {
    "title": "VS Code on Mac",
    "keywords": "",
    "url": "/blog/pages/c/editor/vscode/",
    "body": "可以參考其它人的影音檔。 https://www.youtube.com/watch?v=iIPST6HQgSc 參考文章 Visual Studio Code on macOS Using Clang in Visual Studio Code 若code .沒反應 “code .” is not working in on the command line for Visual Studio Code on OS X/Mac"
  },"/blog/pages/c/template/classTemplate/": {
    "title": "模板類",
    "keywords": "",
    "url": "/blog/pages/c/template/classTemplate/",
    "body": "語法 模板定義 模板形參定義 形參通用名字 逗號 template &lt; class T1 , class T2&gt; 模板定義以關鍵字template開始，後接模板形參表（template parameter list），模板形參是以class開頭，後接形參的通用名字(T1)。模板形參表是用尖括號括住的一個或者多個模板形參的列表，形參之間以逗號分隔。class也可以用typename互相替換。 定義模板類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template &lt;class K, class V&gt; class MyMap{ public: MyMap(){} MyMap(K key1, V value1):key(key1),value(value1){} K getKey(){ return key; } V getValue(){ return value; } private: K key; V value; }; 第1行，template為模板定義，&lt;class K, class V&gt;模板形參定義(type parameter)。 第2行，模板函式的名稱為MyMap。 第5行，建構子，初始私有成員key與value。 第6行，取得私有成員key。 第9行，取得私有成員value。 第13行，私有成員key。 第14行，私有成員value。 使用模板類 1 2 3 4 5 6 7 8 9 10 int main() { MyMap&lt;int,string&gt; myMap(3, \"test\"); cout &lt;&lt; \"myMap key=\" &lt;&lt; myMap.getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap value=\" &lt;&lt; myMap.getValue() &lt;&lt; endl; MyMap&lt;string, string&gt; *myMap_P1 = new MyMap&lt;string,string&gt;(\"abc\",\"def\"); cout &lt;&lt; \"myMap_P1 key=\" &lt;&lt; myMap_P1-&gt;getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap_P1 value=\" &lt;&lt; myMap_P1-&gt;getValue() &lt;&lt; endl; return 0; } 第2行，建立模板類物件，用尖括號&lt;K,V&gt; 指定模板形參類型，K的類型為int，V的類型為string，呼叫傳進二個參數的建構子。 第3行，印出值。 第4行，印出值。 第6行，使用指針建立模板類物件，用尖括號&lt;K,V&gt; 指定模板形參類型，K的類型為string，V的類型為string，使用new的方式建立指針，( “abc”,”def”)呼叫二個參數的建構子。 第7行，使用-&gt;印出值。 第8行，使用-&gt;印印出值。"
  },"/blog/pages/c/template/funTemplate/": {
    "title": "模板函式",
    "keywords": "",
    "url": "/blog/pages/c/template/funTemplate/",
    "body": "模板定義 模板定義 模板形參定義 形參通用名字 逗號 template &lt; class T1 , class T2&gt;"
  },"/blog/pages/c/template/stackTemplate/": {
    "title": "Stack實作(int Array)",
    "keywords": "",
    "url": "/blog/pages/c/template/stackTemplate/",
    "body": "Stack int陣列實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Stack{ private: int *items; //陣列指針 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構子，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指針 items = new int[stacksize]; } ~Stack() { delete [] items;//刪除陣列指針 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const int&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(int&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; 第3行，私有成員屬性items，類型為int指針，指向int陣列的第0筆地址。 第4行，私有成員屬性stacksize，類型為int，存放stack最大的容量。 第5行，私有成員屬性top，類型為int，記錄目前stack最頂端的index位置。 第8行，建構子，初始化成員stacksize與top。 第10行，動態建立int陣列。 第12行，解構子。 第13行，從記憶體釋放items的空間。 第14行，將釋放的空間指向null。 第20行，若top位置在0，表示為空。 第25行，若top位置在stacksize代表空間已滿。 第31行，函式是將item推入stack，參數為參考類型。 第33行，目前stack最頂端的index位置小於stack最大容量就做if的區塊。 第34行，先做items[top] = item的動作，再做top++的動作。 第42行，參數為參考類型，stack彈出頂端的值暫時放置的變量。 第44行，先將top–的動作，再做items[top]的動作。 使用Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } 第2行，建立stack物件，最大存放數量為5。 第3~7行，依序塞入1~5。 第8行，宣告臨時變數item。 第9行，若stack不為空就進入循環。 第10行，將stack的頂端拿出來，放在變數item。 第11行，印出item。 執行結果 item = 5 item = 4 item = 3 item = 2 item = 1 Stack typedef實作 將上面的程式修改成自定義類型DataType。以下有黃色的部分是有變更的程式碼。 typedef int DataType; class Stack{ private: DataType *items; //陣列指針 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構子，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指針 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指針 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); DataType item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } Stack 模板實作 將上面的程式再修改成模板，以下有黃色的部分是有變更的程式碼。 template &lt;class DataType&gt; class Stack{ private: DataType *items; //陣列指針 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構子，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指針 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指針 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack&lt;int&gt; myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; }"
  }}
